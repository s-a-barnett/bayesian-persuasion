var modelName = 'aa-hom';

var inferenceParams = {
  experiment: argv.experiment,
  samples: argv.samples,
  burn: argv.burn,
  lag: argv.lag,
  verbose: (argv.verbose == 'true'), // converting str to bool,
  chain: _.isFinite(argv.chain) ? argv.chain : 1,
  out: argv.out
};

// prior over rsa hom model parameters
var paramsPrior = function() {
  // steepness of logistic stick-to-strength curve
  var gradient = uniformDrift({a:0, b: 10, width: 1})
  // prior threshold of confidence (fixed at 0.5 for simple A&A)
  var threshold = 0.0;
  // variance for mean noise
  var sigma = 0.3//Math.abs(cauchy({location: 0, scale: 1}));
  return {
    'gradient': gradient,
    'threshold': threshold,
    'sigma': sigma
  };
};

var getScore = function(datum, params) {
  // read single observation from overall observations
  var stickLength   = _.toNumber(datum[1]);
  var subjectBelief = _.toNumber(datum[2]);

  // compute belief in idealized model
  var mean = shared.getAAAddingScore('long', stickLength, params);
  var noiseDist = Gaussian({mu: Math.exp(mean), sigma: params.sigma});
  return _.max([Math.log(0.01), noiseDist.score(subjectBelief)]);
};

var batchScore = function(params, obs) {
  var pointScores = mapData({data: obs}, function(datum) {
    var pointScore = getScore(datum, params);

    query.add('pointscore_' + datum[0], pointScore);
    factor(pointScore);

    return pointScore;
  });
  return sum(pointScores);
};

var train = function(obs) {
  return Infer({
    method: 'MCMC',
    samples: inferenceParams.samples,
    burn: inferenceParams.burn,
    lag: inferenceParams.lag,
    verbose: inferenceParams.verbose,
    model: function() {
      var params = paramsPrior();

      var totalScore = batchScore(params, obs);

      query.add('gradient', params.gradient);
      query.add('threshold', params.threshold);
      query.add('sigma', params.sigma);

      query.add('likelihood', totalScore);
      query.add('params', JSON.stringify(params));

      return query;
    }
  })
};

var obs = csv.read('input/' + argv.experiment + '_data_full.csv').slice(1, -1);
var chain = "c" + inferenceParams.chain + argv.experiment;

// write posterior distribution to new file
csv.writeDistTable(train(obs), "param,val", inferenceParams.out + "/" + modelName + "-params-posterior_" + chain + ".csv");
