var modelName = 'rsa-het-speakers-hi';

var inferenceParams = {
  experiment: argv.experiment,
  samples: argv.samples,
  burn: argv.burn,
  lag: argv.lag,
  verbose: (argv.verbose == 'true'), // converting str to bool,
  chain: _.isFinite(argv.chain) ? argv.chain : 1,
  out: argv.out
};

// prior over rsa het model parameters
var groupPrior = function(model) {
  var params = model == 'J2' ? {
    nSticks : uniformDraw([5]),  // number of sticks modelled by judge
    agentBias : uniformDrift({a: 0, b: 10, width: 1}),   // fixed value of judge for S1/S2 speaker
    biasPenalty : uniformDrift({a: 0, b: 10, width: 1}),
  } : model == 'J1' ? {
    nSticks : uniformDraw([5]),  // number of sticks modelled by judge
    agentBias : uniformDrift({a: 0, b: 10, width: 1}),   // fixed value of judge for S1/S2 speaker
    biasPenalty : 0,
  } : model == 'J0' ? {
    nSticks : uniformDraw([5]),  // number of sticks modelled by judge
    agentBias : 0,
    biasPenalty : 0,
  } : console.error('unknown model');
  return extend(params, {
    getJ1Score: shared.getJ1Score_generator(params),
    getJ2Score: shared.getJ2Score_generator(params),
  });
};

var getScore = function(datum, params) {
  // read single observation from overall observations
  var stickLength   = _.toNumber(datum[1]);
  var subjectBelief = _.toNumber(datum[2]);
  // compute belief in idealized model
  var mean = params.level == 'J2' ?
      params.getJ2Score('long', stickLength, params) :
             params.level == 'J1' ?
      params.getJ1Score('long', stickLength, params) :
             params.level == 'J0' ?
      shared.getJ0Score('long', stickLength, params) :
        console.error('unknown level');

  var noiseDist = Gaussian({mu: Math.exp(mean) + params.offset, sigma: params.sigma});
  return {score: _.max([Math.log(0.01), noiseDist.score(subjectBelief)]),
          prediction: Math.exp(mean) + params.offset};
};

var mixtureScore = function(means, sharedParams, groupParams, obs, test) {
  var pointScores = mapData({data: obs}, function(datum) {
    var speakerStick = datum[3] < 0.8 ? 'less' : datum[3];
    var mixtureWeight = means[speakerStick];
    var J0 = observe_fn(datum, extend(sharedParams, groupParams['J0'], {level: 'J0'}));
    var J1 = observe_fn(datum, extend(sharedParams, groupParams['J1'], {level: 'J1'}));
    var J2 = observe_fn(datum, extend(sharedParams, groupParams['J2'], {level: 'J2'}));
    var score = shared.logSumExp([
      J0.score + Math.log(mixtureWeight[0]),
      J1.score + Math.log(mixtureWeight[1]),
      J2.score + Math.log(mixtureWeight[2])
    ]);
    var prediction = J0.prediction * mixtureWeight[0] + J1.prediction * mixtureWeight[1] + J2.prediction * mixtureWeight[2];

    query.add('score_' + datum[0], pointScore);
    query.add('prediction_' + datum[0], prediction);

    factor(score);
    return score;
  });
  return sum(pointScores);
};


var train = function(obs) {
  return Infer({
    method: 'MCMC',
    samples: inferenceParams.samples,
    burn: inferenceParams.burn,
    lag: inferenceParams.lag,
    verbose: inferenceParams.verbose,
    model: function() {
      var sigma = 0.3;
      var offset = uniformDrift({a: -0.5, b: 0.5, width: 0.05});
      var sharedParams = {sigma, offset};

      var means = {
        '0.9' : _.values(dirichletDrift({alpha: Vector([1, 1, 1])}).data),
        '0.8' : _.values(dirichletDrift({alpha: Vector([1, 1, 1])}).data),
        'less' : _.values(dirichletDrift({alpha: Vector([1, 1, 1])}).data),
      };

      var groupParams = {
        'J0' : groupPrior('J0'),
        'J1' : groupPrior('J1'),
        'J2' : groupPrior('J2'),
      };

      var totalScore = mixtureScore(means, sharedParams, groupParams, obs, false);

      query.add('J0nSticks', groupParams['J0'].nSticks);
      query.add('J1nSticks', groupParams['J1'].nSticks);
      query.add('J2nSticks', groupParams['J2'].nSticks);

      query.add('J1agentBias', groupParams['J1'].agentBias);
      query.add('J2agentBias', groupParams['J2'].agentBias);
      query.add('J2biasPenalty', groupParams['J2'].biasPenalty);

      query.add('groupWeight-J0-0.9', means['0.9'][0]);
      query.add('groupWeight-J0-0.8', means['0.8'][0]);
      query.add('groupWeight-J0-less', means['less'][0]);

      query.add('groupWeight-J1-0.9', means['0.9'][1]);
      query.add('groupWeight-J1-0.8', means['0.8'][1]);
      query.add('groupWeight-J1-less', means['less'][1]);

      query.add('groupWeight-J2-0.9', means['0.9'][2]);
      query.add('groupWeight-J2-0.8', means['0.8'][2]);
      query.add('groupWeight-J2-less', means['less'][2]);

      query.add('sigma', sigma);
      query.add('offset', offset);

      query.add('score', totalScore);
      query.add('params', JSON.stringify(extend({sharedParams}, {groupParams}, {means})));

      return query;
    }})
};

var obs = csv.read('input/' + argv.experiment + '_data_full.csv').slice(1, -1);
var chain = "c" + inferenceParams.chain + argv.experiment;
csv.writeDistTable(train(obs), "param,val", inferenceParams.out + "/" + modelName + "-params-posterior_" + chain + ".csv");
