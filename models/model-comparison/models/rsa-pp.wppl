var inferenceParams = {
  experiment: argv.experiment,
  samples: argv.samples,
  burn: argv.burn,
  lag: argv.lag,
  verbose: (argv.verbose == 'true'), // converting str to bool,
  chain: _.isFinite(argv.chain) ? argv.chain : 1,
  out: argv.out
};

// prior over rsa het model parameters
var groupPrior = function(model) {
  var params = model == 'J1' ? {
    nSticks : uniformDraw([5]),  // number of sticks modelled by judge
    agentBias : uniformDrift({a: 0, b: 10, width: 1}),   // fixed value of judge for S1/S2 speaker
  } : model == 'J0' ? {
    nSticks : uniformDraw([5]),  // number of sticks modelled by judge
    agentBias : 0,
  } : {
    nSticks: 5,
    agentBias: 0,
  };
  return extend(params, {getJ1Score: shared.getJ1Score_generator(params)});
};

var rsaHet = function(obs) {

  var observe_fn = function(datum, params) {
    // read single observation from overall observations
    var stickLength   = _.toNumber(datum[1]);
    var subjectBelief = _.toNumber(datum[2]);

    // compute belief in idealized model
    var mean = params.level == 'J1' ? params.getJ1Score('long', stickLength, params) :
          params.level == 'J0' ? shared.getJ0Score('long', stickLength, params) :
          Math.log(0.5);

    var noiseDist = Gaussian({mu: Math.exp(mean) + params.offset, sigma: params.logitSigma});

    factor(_.max([Math.log(0.01), noiseDist.score(subjectBelief)]));

    return noiseDist;
  };

  return Infer({
    method: 'MCMC',
    samples: inferenceParams.samples,
    burn: inferenceParams.burn,
    lag: inferenceParams.lag,
    verbose: inferenceParams.verbose,
    model: function() {
      var logitSigma = 0.3;
      var offset = uniformDrift({a: -0.5, b: 0.5, width: 0.05});
      var sharedParams = {logitSigma, offset};
      var groupParams = {
        'J0' : groupPrior('J0'),
        'J1' : groupPrior('J1'),
      };

      var means = {
        '0.9' : _.values(dirichletDrift({alpha: Vector([1, 1])}).data),
        '0.8' : _.values(dirichletDrift({alpha: Vector([1, 1])}).data),
        'less' : _.values(dirichletDrift({alpha: Vector([1, 1])}).data),
      };

      var speakerSticks = map(function(o) {
        var speakerStick = o[3] < 0.8 ? 'less' : o[3];
        return speakerStick;
      }, obs);

      var levels = map(function(stick) {
        return categorical({ps: means[stick], vs: ['J0', 'J1']})
      }, speakerSticks);

      var noiseDists = mapData({data: obs}, function(datum, i) {
        var level = levels[i].toString();
        var datumParams = extend(sharedParams, groupParams[level], {level});
        var noiseDist = observe_fn(datum, datumParams);
        return noiseDist;
      });

      var beliefs = map(function(d) {return sample(d)}, noiseDists);
      var gameids = map(function(o){return o[0];}, obs);

      return _.zipObject(gameids, beliefs);
    }})
};

// read observations from csv file (slice to skip header and empty final line)
var obs = csv.read('input/' + argv.experiment + '_data_no0.2_0.4.csv').slice(1, -1);

// write posterior distribution to new file
csv.writeJoint(rsaHet(obs), inferenceParams.out + "/rsa-pp-params-posterior_" + argv.experiment + "_" + inferenceParams.chain + ".csv");
