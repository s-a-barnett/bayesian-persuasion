var inferenceParams = {
  samples: argv.samples,
  burn: argv.burn,
  lag: argv.lag,
  verbose: (argv.verbose == 'true'), // converting str to bool
  out: argv.out
};

// prior over rsa het model parameters
var groupPrior = function(group) {
  var params = {
    nSticks : uniformDraw([2, 3, 4, 5]),  // number of sticks modelled by judge
    agentBias : 10 * beta({a: 2, b: 5})   // fixed value of judge for S1 speaker
  };
  return extend(params, {getJ1Score: shared.getJ1Score_generator(params)});
};

var rsaHet = function(obs, output_handle) {

  var observe_fn = function(datum, params) {
    // read single observation from overall observations
    var stickLength   = _.toNumber(datum[1]);
    var subjectBelief = _.toNumber(datum[2]);

    // compute belief in idealized model
    var mean = params.level == 'J1' ?
        params.getJ1Score('long', stickLength, params) :
        shared.getJ0Score('long', stickLength, params) ;

    // mu represents the mean of the normal distribution given by the logit
    //   of the model belief
    var mu = mean - Math.log1p(-Math.exp(mean));

    var noiseDist = LogitNormal({mu: mu, sigma: params.logitSigma, a: 0., b: 1.});

    // in Gelman et al. notation, this is log(p(y_i | Î¸^s))
    //   for i-th observation, s-th posterior sample
    var pointScore = noiseDist.score(subjectBelief);
    globalStore.sum += pointScore;

    // write pointScore into separate external file
    csv.writeLine(_.values(_.omit(params, ['getJ1Score'])).toString() + "," +
                  datum[0] + ',' + datum[1] + ',' + datum[2] + "," + pointScore,
                  output_handle);

    factor(pointScore);
  };

  return Infer({
    method: 'MCMC',
    samples: inferenceParams.samples,
    burn: inferenceParams.burn,
    lag: inferenceParams.lag,
    verbose: inferenceParams.verbose,
    model: function() {
      var groupWeight = uniformDrift({a: 0, b: 1, width: .1});
      var logitSigma = uniformDrift({a: 0, b: 2, width: .1});
      var groupParams = {
        'J0' : groupPrior('J0'),
        'J1' : groupPrior('J1')
      };

      var sharedParams = {groupWeight, logitSigma};

      globalStore.sum = 0;
      mapData({data: obs}, function(datum) {
        var level = flip(sharedParams.groupWeight) ? 'J1' : 'J0';
        var datumParams = extend(sharedParams, groupParams[level], {level});
        query.add('p' + datum[0], level);
        observe_fn(datum, datumParams);
      });

      csv.writeLine(_.values(sharedParams).toString() + "," +
                    _.values(_.omit(groupParams['J0'], ['getJ1Score'])).toString() + "," +
                    _.values(_.omit(groupParams['J1'], ['getJ1Score'])).toString() + "," +
                    globalStore.sum,
                    sumScore_handle);

      query.add('J0nSticks', groupParams['J0'].nSticks)
      query.add('J1nSticks', groupParams['J1'].nSticks)
      query.add('J0agentBias', groupParams['J0'].agentBias)
      query.add('J1agentBias', groupParams['J1'].agentBias)
      query.add('logitSigma', sharedParams.logitSigma)
      query.add('groupWeight', sharedParams.groupWeight)
      return query;
    }})
};

// read observations from csv file (slice to skip header and empty final line)
var obs = csv.read('data/rsa-het-data.csv').slice(1, -1);

// open pointScore file
var output_handle = csv.open(inferenceParams.out + "results/rsa-het-pointScores.csv");
csv.writeLine("groupWeight,logitSigma,nSticks,agentBias,level,gameid,stickLength,subjectBelief,score", output_handle);

// open sumScore file
var sumScore_handle = csv.open(inferenceParams.out + "results/rsa-het-sumScores.csv");
csv.writeLine("groupWeight,logitSigma,J0nSticks,J0agentBias,J1nSticks,J1agentBias,score", sumScore_handle);

// write posterior distribution to new file
csv.writeDistTable(rsaHet(obs, output_handle), "param,val", inferenceParams.out + "results/rsa-het-params-posterior.csv");
csv.close(output_handle);
csv.close(sumScore_handle);
