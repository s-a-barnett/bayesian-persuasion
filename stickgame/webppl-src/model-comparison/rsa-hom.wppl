var inferenceParams = {
  samples: argv.samples,
  burn: argv.burn,
  lag: argv.lag,
  verbose: (argv.verbose == 'true'), // converting str to bool
  out: argv.out
};

// open pointScore file
var output_handle = csv.open(inferenceParams.out + "results/rsa-hom-pointScores.csv");
csv.writeLine("gameid,score", output_handle);

// prior over rsa hom model parameters
var paramsPrior = function(level) {
  // number of sticks modelled by judge
  var nSticks = (level != 'noise') ? uniformDraw([2, 3, 4, 5]) : 5;
  // fixed value of judge for S1 speaker
  var agentBias = _.includes(['J1', 'J2'], level) ? uniformDrift({a: 0, b: 10, width: 1}) : 0;
  // fixed value of biasPenalty for S2 speaker
  var biasPenalty = (level == 'J2') ? uniformDrift({a: 0, b: 10, width: 1}) : 0;
  // variance for mean noise
  var logitSigma = 1;
  return {
    'nSticks': nSticks,
    'agentBias': agentBias,
    'biasPenalty': biasPenalty,
    'logitSigma': logitSigma,
    'level': level
  };
};

var rsaHom = function(obs, output_handle) {

  var observe_fn = function(datum, params, sParams) {
    // read single observation from overall observations
    var stickLength   = _.toNumber(datum[1]);
    var subjectBelief = _.toNumber(datum[2]);
    var speakerStick  = _.toNumber(datum[3]);

    // compute belief in idealized model
    var mean = params.level == 'J2' ?
        params.getJ2Score('long', stickLength, params) :
               params.level == 'J1' ?
        params.getJ1Score('long', stickLength, params) :
               params.level == 'J0' ?
        shared.getJ0Score('long', stickLength, params) :
        0.5;

    // mu represents the mean of the normal distribution given by the logit
    //   of the model belief
    var mu = mean - Math.log1p(-Math.exp(mean));

    var noiseDist = params.level == 'noise' ?
      Uniform({a: 0., b: 1.}) :
      LogitNormal({mu: mu, sigma: params.logitSigma, a: 0., b: 1.});

    // in Gelman et al. notation, this is log(p(y_i | Î¸^s))
    //   for i-th observation, s-th posterior sample
    var pointScore = noiseDist.score(subjectBelief);
    globalStore.totalScore += pointScore;

    var iter = shared.iterationTracker() / obs.length;
    var floor_iter = _.floor(iter);

    // write pointScore into separate external file
    if (shared.isRecordedIter(floor_iter, inferenceParams.burn, inferenceParams.lag)) {
      csv.writeLine(datum[0] + "," + pointScore, output_handle);
      if (floor_iter + 1 == iter + (1/obs.length)) {
        console.log(globalStore.totalScore);
      };
    };

    factor(pointScore);
  };

  return Infer({method: 'MCMC',
                samples: inferenceParams.samples,
                burn: inferenceParams.burn,
                lag: inferenceParams.lag,
                verbose: inferenceParams.verbose,
                model: function() {

    // determines whether population treated as J0, J1, or J2
    var level = categorical({vs: ['noise', 'J0', 'J1', 'J2']});
    var raw_params = paramsPrior(level);

    var params = extend(raw_params, {
      getJ1Score: shared.getJ1Score_generator(raw_params),
      getJ2Score: shared.getJ2Score_generator(raw_params)
    });

    globalStore.totalScore = 0;
    mapData({data: obs}, function(datum) {
      query.add('p' + datum[0], level);
      observe_fn(datum, params);
    });

    query.add('nSticks', params.nSticks);
    query.add('agentBias', params.agentBias);
    query.add('biasPenalty', params.biasPenalty);

    return query;
  }})
};

// read observations from csv file (slice to skip header and empty final line)
var obs = csv.read('data/rsa-het-data.csv').slice(1, -1);

// write posterior distribution to new file
csv.writeJoint(rsaHom(obs, output_handle), inferenceParams.out + "results/rsa-hom-params-posterior.csv");
csv.close(output_handle);
