// Ensure equal numbers on either side of 0.5
var possibleSticks = map(function(v) {
  return _.round(v, 3);
}, _.range(0.0, 1.1, .1));

// Place prior over combinations to ignore order of sticks
var stickPrior = function(nSticks) {
  return repeat(nSticks, function() {return categorical({vs: possibleSticks});});
};

// Uniform discrete prior over four different bias possibilities
var biasPrior = function(params) {
  return categorical({vs: ['neutral', 'informative', 'shortest', 'longest']});
};

// L0 judge: assumes data received are i.i.d.
// Note: b/c agentIDs are irrelevant, we assume here the observations are just array of lengths to improve caching
var J0 = cache(function(obs, params) {
  // 0 < recencyBias <= 1, where recencyBias of 1 means no bias
  var recencyBias = _.isFinite(params.recencyBias) ? params.recencyBias : 1.0;
  // recursively condition on stick being in list of sticks
  var observe_fn = function(observations, sticks) {
    if(observations.length > 0) {
      var datum = first(observations)
      // recencyFactor tends _upwards_ from recencyBias^(obs.length - 1) to 1
      // need to divide by params.choiceSize to properly count the number of observations,
      //   as observations here are just array of lengths
      var recencyFactor = 1. // Math.pow(recencyBias, (observations.length / params.choiceSize) - 1);
      // for earlier observations, the non-include factor starts close to 0
      // for the final observation, the non-include factor is -100
      factor(recencyFactor * (_.includes(sticks, datum)? 0 : -100));
      observe_fn(rest(observations), shared.removeSingleElement(datum, sticks))
    }
  };

  return Infer({method: 'enumerate', model: function() {
    // assume latent sticks drawn i.i.d
    var sticks = stickPrior(params.nSticks)

    // Condition on observations
    observe_fn(obs, sticks)

    var stat = params.statistic == 'mean' ? _.mean(sticks) :
               params.statistic == 'median' ? shared.median(sticks) :
               error('statistic must be "mean" or "median"');

    // return marginal distribution of interest
    return {
      stat: stat,
      isLong: stat >= .5 ? 'long' : 'short'
    }
  }})
});

// S1 agent has a bias towards longer or shorter sticks, depending on what she
// thinks the judge will infer about the mean stick length
// Note: sticks only involve those currently available to select
// prevEvidence refers to the stick observations already made
var S1 = cache(function(bias, sticks, prevEvidence, agentID, params) {

  return Infer({method: 'enumerate', model: function() {
    // stickSubset constrained to actual sticks present
    var stickSubset = categorical({vs: shared.k_combinations(sticks, params.choiceSize)});
    // lyingSubset can be any subset of possible sticks
    var lyingSubset = stickPrior(params.choiceSize);

    if (bias == 'neutral') {
      // choose stickSubset uniformly at random
      factor(0);
    } else if (bias == 'shortest' || bias == 'longest') {
      // choose lyingSubset that maximises the desired outcome
      var evidence = prevEvidence.concat(
        [{'agentID': agentID, stickLength: lyingSubset}]
      );
      var desiredOutcome = bias == 'shortest' ? 'short' : 'long';
      factor(params.liarAlpha * marginalize(J0(_.flatten(_.map(evidence, 'stickLength')), params), 'isLong').score(desiredOutcome));
    } else if (bias == 'informative') {
      // compute whether the sample is truly 'long' or 'short'
      var evidence = prevEvidence.concat(
        [{'agentID': agentID, stickLength: stickSubset}]
      );
      var allSticks = _.flatten([_.map(prevEvidence, 'stickLength'), sticks]);
      var stat = params.statistic == 'mean' ? _.mean(allSticks) :
                 params.statistic == 'median' ? shared.median(allSticks) :
                 error('statistic must be "mean" or "median"');
      var groundTruth = stat >= .5 ? 'long' : 'short';
      // choose stickSubset to maximise judge's belief in the truth
      factor(params.alpha * marginalize(J0(_.flatten(_.map(evidence, 'stickLength')), params), 'isLong').score(groundTruth));
    };

    return (bias == 'shortest' || bias == 'longest') ? lyingSubset : stickSubset;
  }});
});

// L1 judge models bias of agent
var J1 = cache(function(obs, params) {
  // 0 < recencyBias <= 1, where recencyBias of 1 means no bias
  var recencyBias = _.isFinite(params.recencyBias) ? params.recencyBias : 1.0;

  // Recursively observe, accounting for earlier choices
  // Keeps track of previous observations in prevObs
  // Models samples as being from pragmaticAgent
  var observe_fn = function(observations, prevObs, sticks, biases) {
    if(observations.length > 0) {
      var datum = first(observations)

      // Shortcut to avoid evaluating speaker for cases where
      // observation isn't even in list of sticks
      var recencyFactor = Math.pow(recencyBias, observations.length - 1);
      var S1_prob = S1(biases[datum.agentID], sticks, prevObs, datum.agentID, params).score(datum.stickLength);
      factor(recencyFactor * (shared.includesList(sticks, datum.stickLength) ? S1_prob : -100));

      // continue to next observations
      observe_fn(
        rest(observations),
        prevObs.concat(datum),
        shared.removeMultipleElements(datum.stickLength, sticks),
        biases
      )
    }
  }

  return Infer({method: 'enumerate', model: function() {
    // assume latent sticks drawn i.i.d
    var sticks = stickPrior(params.nSticks);

    var biases = {
      agent0: biasPrior(params)
    };

    // Condition on observations coming from biased agent
    observe_fn(obs, [], sticks, biases);

    var stat = params.statistic == 'mean' ? _.mean(sticks) :
               params.statistic == 'median' ? shared.median(sticks) :
               error('statistic must be "mean" or "median"');

    // return marginal distributions of interest
    return {
      stat: stat,
      isLong: stat >= .5 ? 'long' : 'short',
      bias0: biases['agent0']
    }
  }})
})

// S2 reasons about judge that is thinking about bias
var S2 = cache(function(sticks, prevEvidence, agentID, params) {
  return Infer({method: 'enumerate', model: function() {
    var stickSubset = categorical({vs: shared.k_combinations(sticks, params.choiceSize)});

    var evidence = prevEvidence.concat(
      [{'agentID': agentID, stickLength: stickSubset}]
    );
    var allSticks = _.flatten([_.map(prevEvidence, 'stickLength'), sticks]);

    var stat = params.statistic == 'mean' ? _.mean(allSticks) :
               params.statistic == 'median' ? shared.median(allSticks) :
               error('statistic must be "mean" or "median"');
    var groundTruth = stat >= .5 ? 'long' : 'short';

    factor(params.alpha * marginalize(J1(evidence, params), "isLong").score(groundTruth));

    return stickSubset;
  }})
})
